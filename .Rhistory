axis.title.y.left = element_text(color = eviction_color)
)
}
# Create lagged unemployment variables
eviction_econ_lag <- eviction_econ %>%
arrange(date) %>%
mutate(
unemp_lag1 = lag(unemployment_rate, 1),
unemp_lag2 = lag(unemployment_rate, 2),
unemp_lag3 = lag(unemployment_rate, 3),
unemp_change = unemployment_rate - lag(unemployment_rate, 1)
) %>%
filter(!is.na(unemp_lag3), !is.na(month_filings))
# Only proceed if we have enough data
if(nrow(eviction_econ_lag) >= 5) {
# Correlation at different lags
lag_cors <- data.frame(
Lag = c("Same Month", "1 Month Lag", "2 Month Lag", "3 Month Lag"),
Correlation = c(
cor(eviction_econ_lag$month_filings, eviction_econ_lag$unemployment_rate, use = "complete.obs"),
cor(eviction_econ_lag$month_filings, eviction_econ_lag$unemp_lag1, use = "complete.obs"),
cor(eviction_econ_lag$month_filings, eviction_econ_lag$unemp_lag2, use = "complete.obs"),
cor(eviction_econ_lag$month_filings, eviction_econ_lag$unemp_lag3, use = "complete.obs")
)
)
# Fix the order - set factor levels explicitly
lag_cors$Lag <- factor(lag_cors$Lag,
levels = c("Same Month", "1 Month Lag", "2 Month Lag", "3 Month Lag"))
ggplot(lag_cors, aes(x = Lag, y = Correlation, fill = Correlation)) +
geom_col() +
geom_text(aes(label = round(Correlation, 3)), vjust = ifelse(lag_cors$Correlation > 0, -0.5, 1.5)) +
scale_fill_gradient2(low = unemp_color, mid = "white", high = eviction_color, midpoint = 0) +
labs(
title = "Correlation Between Unemployment and Evictions at Different Lags",
subtitle = "Testing whether economic shocks precede eviction changes",
x = "Lag Period",
y = "Pearson Correlation"
) +
plotTheme +
theme(legend.position = "none")
} else {
cat("Not enough overlapping data for lag analysis.\n")
cat("Available rows:", nrow(eviction_econ_lag), "\n")
}
# Get Philadelphia census tracts
philly_tracts <- tracts(state = "PA", county = "Philadelphia", year = 2022) %>%
st_transform(crs = 4326)
cat("Philadelphia has", nrow(philly_tracts), "census tracts\n")
# Prepare tract filings data
tract_filings_clean <- tract_filing_rate %>%
mutate(GEOID = as.character(id)) %>%
group_by(GEOID) %>%
summarize(
avg_month_rate = mean(month_rate, na.rm = TRUE),
total_filings = sum(month_filings, na.rm = TRUE),
n_months = n()
)
# Join to geometry
evictions_geo <- philly_tracts %>%
left_join(tract_filings_clean, by = "GEOID")
# Map
ggplot(evictions_geo) +
geom_sf(aes(fill = avg_month_rate), color = "white", linewidth = 0.1) +
scale_fill_viridis_c(option = "magma", na.value = "grey90",
name = "Avg Monthly\nFiling Rate") +
labs(
title = "Average Eviction Filing Rate by Census Tract",
subtitle = "Philadelphia, PA - Spatial distribution of eviction vulnerability"
) +
mapTheme
# Prepare data for spatial analysis
evictions_geo_clean <- evictions_geo %>%
filter(!is.na(avg_month_rate))
cat("Tracts with eviction data:", nrow(evictions_geo_clean), "\n")
# Only proceed if we have enough spatial data
if(nrow(evictions_geo_clean) >= 30) {
# Transform to projected CRS for spatial analysis
evictions_geo_proj <- evictions_geo_clean %>%
st_transform(crs = 32618) %>%
st_make_valid()  # Fix any invalid geometries
# Try spatial autocorrelation analysis
spatial_analysis_success <- FALSE
moran_test <- NULL
hotspot_tracts <- data.frame()
tryCatch({
# Create neighbor list
nb <- poly2nb(evictions_geo_proj, queen = TRUE)
# Remove isolates if any
n_isolates <- sum(card(nb) == 0)
cat("Isolated tracts (no neighbors):", n_isolates, "\n")
if(n_isolates < nrow(evictions_geo_proj) / 2) {  # Only proceed if less than half are isolates
# Create spatial weights
lw <- nb2listw(nb, style = "W", zero.policy = TRUE)
# Global Moran's I
moran_result <- moran.test(evictions_geo_proj$avg_month_rate, lw,
zero.policy = TRUE, na.action = na.omit)
cat("\n=== Global Moran's I Test ===\n")
cat("Moran's I:", round(moran_result$estimate[1], 4), "\n")
cat("P-value:", format(moran_result$p.value, scientific = TRUE), "\n")
cat("Interpretation:", ifelse(moran_result$p.value < 0.05,
"SIGNIFICANT spatial clustering", "No significant clustering"), "\n")
# Store for later use - use global assignment
moran_test <<- moran_result
# Local Moran's I
local_result <- localmoran(evictions_geo_proj$avg_month_rate, lw,
zero.policy = TRUE, na.action = na.omit)
evictions_geo_proj$local_i <- local_result[, 1]
evictions_geo_proj$local_p <- local_result[, 5]
# Calculate spatial lag
mean_val <- mean(evictions_geo_proj$avg_month_rate, na.rm = TRUE)
evictions_geo_proj$lag_rate <- lag.listw(lw, evictions_geo_proj$avg_month_rate,
zero.policy = TRUE, NAOK = TRUE)
# Classify clusters - use global assignment
evictions_geo_proj <<- evictions_geo_proj %>%
mutate(
lisa_cluster = case_when(
is.na(local_p) | is.na(lag_rate) ~ "Not Significant",
local_p > 0.05 ~ "Not Significant",
avg_month_rate > mean_val & lag_rate > mean_val ~ "High-High (Hot Spot)",
avg_month_rate < mean_val & lag_rate < mean_val ~ "Low-Low (Cold Spot)",
avg_month_rate > mean_val & lag_rate < mean_val ~ "High-Low (Outlier)",
TRUE ~ "Low-High (Outlier)"
)
)
# Store hotspot tracts for summary - use global assignment
hotspot_tracts <<- evictions_geo_proj %>%
st_drop_geometry() %>%
filter(lisa_cluster == "High-High (Hot Spot)")
cat("\nLISA Cluster Summary:\n")
print(table(evictions_geo_proj$lisa_cluster))
# Plot LISA map
ggplot(evictions_geo_proj %>% st_transform(4326)) +
geom_sf(aes(fill = lisa_cluster), color = "white", linewidth = 0.1) +
scale_fill_manual(
values = c(
"High-High (Hot Spot)" = "#d7191c",
"Low-Low (Cold Spot)" = "#2c7bb6",
"High-Low (Outlier)" = "#fdae61",
"Low-High (Outlier)" = "#abd9e9",
"Not Significant" = "grey90"
),
name = "LISA Cluster",
drop = FALSE
) +
labs(
title = "Local Spatial Autocorrelation (LISA) of Eviction Rates",
subtitle = paste("Moran's I =", round(moran_result$estimate[1], 3)),
caption = "Red = High eviction clusters | Blue = Low eviction clusters"
) +
mapTheme
spatial_analysis_success <<- TRUE
}
}, error = function(e) {
cat("\n⚠️ Spatial analysis error:", conditionMessage(e), "\n")
})
# Fallback: Simple quantile map if spatial analysis failed
if(!spatial_analysis_success) {
cat("\nUsing quantile-based visualization instead...\n")
evictions_geo_clean <- evictions_geo_clean %>%
mutate(
rate_category = cut(avg_month_rate,
breaks = quantile(avg_month_rate, probs = seq(0, 1, 0.25), na.rm = TRUE),
labels = c("Low (Q1)", "Medium-Low (Q2)", "Medium-High (Q3)", "High (Q4)"),
include.lowest = TRUE)
)
ggplot(evictions_geo_clean) +
geom_sf(aes(fill = rate_category), color = "white", linewidth = 0.1) +
scale_fill_viridis_d(option = "magma", name = "Eviction Rate") +
labs(
title = "Eviction Rate Distribution by Census Tract",
subtitle = "Quartile-based classification"
) +
mapTheme
}
} else {
cat("Not enough spatial data for analysis (need 30+ tracts, have", nrow(evictions_geo_clean), ")\n")
# Just show basic map
ggplot(evictions_geo) +
geom_sf(aes(fill = avg_month_rate), color = "white", linewidth = 0.1) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "Eviction Rates by Census Tract") +
mapTheme
}
# Check if lisa_cluster exists (from section 4.3)
if(exists("evictions_geo_proj") && "lisa_cluster" %in% names(evictions_geo_proj)) {
# Identify top hot spot tracts
hotspot_tracts <- evictions_geo_proj %>%
filter(lisa_cluster == "High-High (Hot Spot)") %>%
st_drop_geometry() %>%
arrange(desc(avg_month_rate)) %>%
select(GEOID, avg_month_rate, total_filings, n_months)
cat("Number of Hot Spot tracts:", nrow(hotspot_tracts), "\n")
if(nrow(hotspot_tracts) > 0) {
cat("Average eviction rate in hot spots:", round(mean(hotspot_tracts$avg_month_rate), 3), "\n")
kable(head(hotspot_tracts, 10), digits = 3,
caption = "Top 10 Eviction Hot Spot Census Tracts") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
}
} else {
# Fallback: show top tracts by rate (without LISA clustering)
cat("LISA analysis not available. Showing top tracts by eviction rate:\n\n")
hotspot_tracts <- evictions_geo %>%
filter(!is.na(avg_month_rate)) %>%
st_drop_geometry() %>%
arrange(desc(avg_month_rate)) %>%
head(10) %>%
select(GEOID, avg_month_rate, total_filings, n_months)
kable(hotspot_tracts, digits = 3,
caption = "Top 10 Census Tracts by Eviction Rate") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
}
# Analyze by racial composition
tract_demo <- tract_filing_rate %>%
mutate(
# Note: Using pct_black (not pct_af_am) based on actual column names
# Data uses proportions (0-1), not percentages (0-100)
majority_type = case_when(
pct_white > 0.5 ~ "Majority White",
pct_black > 0.5 ~ "Majority Black",
pct_hispanic > 0.5 ~ "Majority Hispanic",
TRUE ~ "No Majority"
)
)
demo_summary <- tract_demo %>%
group_by(majority_type) %>%
summarize(
avg_rate = mean(month_rate, na.rm = TRUE),
median_rate = median(month_rate, na.rm = TRUE),
n_obs = n(),
n_tracts = n_distinct(id)
) %>%
arrange(desc(avg_rate))
ggplot(demo_summary, aes(x = reorder(majority_type, -avg_rate), y = avg_rate, fill = majority_type)) +
geom_col() +
geom_errorbar(aes(ymin = avg_rate * 0.9, ymax = avg_rate * 1.1), width = 0.2) +
geom_text(aes(label = paste0(round(avg_rate, 3), "\n(n=", n_tracts, ")")), vjust = -0.3, size = 3.5) +
scale_fill_brewer(palette = "Set2") +
labs(
title = "Average Eviction Rate by Neighborhood Racial Composition",
subtitle = "Equity Analysis: Disparities in eviction burden",
x = "Neighborhood Type",
y = "Average Monthly Filing Rate",
caption = "n = number of unique census tracts"
) +
plotTheme +
theme(legend.position = "none") +
ylim(0, max(demo_summary$avg_rate) * 1.3)
# Boxplot comparison
ggplot(tract_demo, aes(x = majority_type, y = month_rate, fill = majority_type)) +
geom_boxplot(outlier.alpha = 0.3) +
scale_fill_brewer(palette = "Set2") +
labs(
title = "Distribution of Monthly Eviction Rates by Neighborhood Type",
subtitle = "Boxplots show median, quartiles, and outliers",
x = "Neighborhood Type",
y = "Monthly Filing Rate"
) +
plotTheme +
theme(legend.position = "none") +
coord_cartesian(ylim = c(0, quantile(tract_demo$month_rate, 0.95, na.rm = TRUE)))
# Average by tract
tract_avg <- tract_filing_rate %>%
group_by(id) %>%
summarize(
avg_rate = mean(month_rate, na.rm = TRUE),
pct_black = first(pct_black),
pct_white = first(pct_white),
pct_hispanic = first(pct_hispanic)
)
p1 <- ggplot(tract_avg, aes(x = pct_black * 100, y = avg_rate)) +
geom_point(alpha = 0.5, color = "#1b9e77") +
geom_smooth(method = "lm", se = TRUE, color = eviction_color) +
labs(
title = "% Black Population",
x = "% Black",
y = "Avg Eviction Rate"
) +
plotTheme
p2 <- ggplot(tract_avg, aes(x = pct_white * 100, y = avg_rate)) +
geom_point(alpha = 0.5, color = "#d95f02") +
geom_smooth(method = "lm", se = TRUE, color = eviction_color) +
labs(
title = "% White Population",
x = "% White",
y = "Avg Eviction Rate"
) +
plotTheme
p3 <- ggplot(tract_avg, aes(x = pct_hispanic * 100, y = avg_rate)) +
geom_point(alpha = 0.5, color = "#7570b3") +
geom_smooth(method = "lm", se = TRUE, color = eviction_color) +
labs(
title = "% Hispanic Population",
x = "% Hispanic",
y = "Avg Eviction Rate"
) +
plotTheme
p1 + p2 + p3 +
plot_annotation(
title = "Eviction Rates by Racial Composition",
subtitle = "Correlation between neighborhood demographics and eviction vulnerability"
)
# Detailed equity summary
equity_summary <- tract_demo %>%
group_by(majority_type) %>%
summarize(
`Mean Eviction Rate` = mean(month_rate, na.rm = TRUE),
`Median Eviction Rate` = median(month_rate, na.rm = TRUE),
`Std Dev` = sd(month_rate, na.rm = TRUE),
`Max Rate` = max(month_rate, na.rm = TRUE),
`N Observations` = n(),
`N Tracts` = n_distinct(id)
) %>%
arrange(desc(`Mean Eviction Rate`))
# Calculate disparity ratio
baseline_rate <- equity_summary %>%
filter(majority_type == "Majority White") %>%
pull(`Mean Eviction Rate`)
equity_summary <- equity_summary %>%
mutate(`Disparity Ratio` = `Mean Eviction Rate` / baseline_rate)
kable(equity_summary, digits = 3,
caption = "Eviction Rate Disparities by Neighborhood Type") %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
row_spec(which.max(equity_summary$`Mean Eviction Rate`), bold = TRUE, background = "#ffcccc")
# Analyze how spatial patterns change over time
tract_time <- tract_filing_rate %>%
mutate(
GEOID = as.character(id),
date = as.Date(month_date)
)
# Create time periods
tract_time <- tract_time %>%
mutate(
period = case_when(
date < as.Date("2020-03-01") ~ "Pre-COVID",
date >= as.Date("2020-03-01") & date < as.Date("2021-01-01") ~ "COVID-2020",
date >= as.Date("2021-01-01") & date < as.Date("2022-01-01") ~ "COVID-2021",
date >= as.Date("2022-01-01") ~ "Post-COVID"
)
)
# Aggregate by period and tract
period_rates <- tract_time %>%
group_by(GEOID, period) %>%
summarize(
avg_rate = mean(month_rate, na.rm = TRUE),
.groups = "drop"
) %>%
pivot_wider(names_from = period, values_from = avg_rate)
# Join to geometry for mapping
period_geo <- philly_tracts %>%
left_join(period_rates, by = "GEOID")
# Check available periods
available_periods <- names(period_rates)[-1]
cat("Available time periods:", paste(available_periods, collapse = ", "), "\n")
# Create maps for each available period
map_list <- list()
for(period_name in available_periods) {
if(period_name %in% names(period_geo)) {
p <- ggplot(period_geo) +
geom_sf(aes(fill = .data[[period_name]]), color = NA) +
scale_fill_viridis_c(option = "magma", na.value = "grey90", limits = c(0, 0.015)) +
labs(title = period_name, fill = "Rate") +
mapTheme +
theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm"))
map_list[[period_name]] <- p
}
}
if(length(map_list) > 0) {
wrap_plots(map_list, ncol = 2) +
plot_annotation(
title = "Evolution of Eviction Spatial Patterns Over Time",
subtitle = "How eviction geography changed through COVID-19 pandemic"
)
}
# Create analysis dataset - with error handling
if(exists("eviction_econ") && nrow(eviction_econ) > 0) {
analysis_df <- eviction_econ %>%
filter(!is.na(unemployment_rate)) %>%
select(date, month_filings, percentage_diff, unemployment_rate,
any_of("cpi_value"))
# Add lagged variables
analysis_df <- analysis_df %>%
arrange(date) %>%
mutate(
filings_change = month_filings - lag(month_filings),
unemp_change = unemployment_rate - lag(unemployment_rate),
unemp_lag1 = lag(unemployment_rate, 1),
unemp_lag2 = lag(unemployment_rate, 2)
) %>%
filter(!is.na(unemp_lag2))
cat("Analysis dataset has", nrow(analysis_df), "observations\n")
# Correlation matrix
if(nrow(analysis_df) > 5) {
cor_vars <- analysis_df %>%
select(month_filings, percentage_diff, unemployment_rate, unemp_lag1, unemp_lag2) %>%
na.omit()
if (nrow(cor_vars) > 5) {
cor_matrix <- cor(cor_vars)
corrplot(cor_matrix,
method = "color",
type = "upper",
addCoef.col = "black",
tl.col = "black",
tl.srt = 45,
col = colorRampPalette(c(unemp_color, "white", eviction_color))(100),
title = "Correlation Matrix: Evictions and Economic Indicators",
mar = c(0, 0, 2, 0))
}
} else {
cat("Not enough data for correlation matrix.\n")
}
} else {
cat("eviction_econ not available. Skipping correlation analysis.\n")
analysis_df <- data.frame()  # Create empty df to prevent later errors
}
if(exists("analysis_df") && nrow(analysis_df) > 5) {
# Eviction vs Unemployment
p1 <- ggplot(analysis_df, aes(x = unemployment_rate, y = month_filings)) +
geom_point(color = unemp_color, alpha = 0.7, size = 3) +
geom_smooth(method = "lm", se = TRUE, color = eviction_color) +
labs(
title = "Evictions vs Unemployment",
subtitle = paste("r =", round(cor(analysis_df$month_filings, analysis_df$unemployment_rate, use = "complete.obs"), 3)),
x = "Unemployment Rate (%)",
y = "Monthly Filings"
) +
plotTheme
# Eviction vs Lagged Unemployment
p2 <- ggplot(analysis_df, aes(x = unemp_lag1, y = month_filings)) +
geom_point(color = cpi_color, alpha = 0.7, size = 3) +
geom_smooth(method = "lm", se = TRUE, color = eviction_color) +
labs(
title = "Evictions vs Lagged Unemployment (1 month)",
subtitle = paste("r =", round(cor(analysis_df$month_filings, analysis_df$unemp_lag1, use = "complete.obs"), 3)),
x = "Unemployment Rate (1 month lag)",
y = "Monthly Filings"
) +
plotTheme
print(p1 + p2)
} else {
cat("Not enough overlapping data for scatter plots.\n")
}
eviction_summary <- eviction_trends_clean %>%
summarize(
`Mean Monthly Filings` = mean(month_filings, na.rm = TRUE),
`SD Monthly Filings` = sd(month_filings, na.rm = TRUE),
`Min Filings` = min(month_filings, na.rm = TRUE),
`Max Filings` = max(month_filings, na.rm = TRUE),
`Mean % Diff from Baseline` = mean(percentage_diff, na.rm = TRUE),
`Months Above Baseline` = sum(percentage_diff > 0, na.rm = TRUE),
`Total Months` = n()
) %>%
pivot_longer(everything(), names_to = "Statistic", values_to = "Value")
kable(eviction_summary, digits = 2, caption = "Eviction Trends Summary") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
if(exists("analysis_df") && nrow(analysis_df) > 0) {
econ_summary <- analysis_df %>%
summarize(
`Mean Unemployment Rate` = mean(unemployment_rate, na.rm = TRUE),
`Max Unemployment Rate` = max(unemployment_rate, na.rm = TRUE),
`Min Unemployment Rate` = min(unemployment_rate, na.rm = TRUE),
`Correlation: Eviction-Unemployment` = cor(month_filings, unemployment_rate, use = "complete.obs"),
`Correlation: Eviction-Lagged Unemp` = cor(month_filings, unemp_lag1, use = "complete.obs")
) %>%
pivot_longer(everything(), names_to = "Statistic", values_to = "Value")
kable(econ_summary, digits = 3, caption = "Economic Indicators Summary") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
} else {
# Use unemp_long directly
unemp_summary <- unemp_long %>%
summarize(
`Mean Unemployment Rate` = mean(unemployment_rate, na.rm = TRUE),
`Max Unemployment Rate` = max(unemployment_rate, na.rm = TRUE),
`Min Unemployment Rate` = min(unemployment_rate, na.rm = TRUE),
`Observations` = n()
) %>%
pivot_longer(everything(), names_to = "Statistic", values_to = "Value")
kable(unemp_summary, digits = 3, caption = "Unemployment Data Summary") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
}
# Calculate key temporal stats
avg_filings <- mean(eviction_trends_clean$month_filings, na.rm = TRUE)
max_filings <- max(eviction_trends_clean$month_filings, na.rm = TRUE)
max_date <- eviction_trends_clean$date[which.max(eviction_trends_clean$month_filings)]
# Calculate correlations - with fallback
if(exists("analysis_df") && nrow(analysis_df) > 5) {
cor_unemp <- cor(analysis_df$month_filings, analysis_df$unemployment_rate, use = "complete.obs")
cor_lag <- cor(analysis_df$month_filings, analysis_df$unemp_lag1, use = "complete.obs")
} else {
# Use eviction_econ_lag if available
if(exists("eviction_econ_lag") && nrow(eviction_econ_lag) > 5) {
cor_unemp <- cor(eviction_econ_lag$month_filings, eviction_econ_lag$unemployment_rate, use = "complete.obs")
cor_lag <- cor(eviction_econ_lag$month_filings, eviction_econ_lag$unemp_lag1, use = "complete.obs")
} else {
cor_unemp <- NA
cor_lag <- NA
}
}
# Get Moran's I result - with fallback if spatial analysis failed
if(exists("moran_test") && !is.null(moran_test) && !is.null(moran_test$estimate)) {
moran_i <- round(moran_test$estimate[1], 3)
} else {
moran_i <- "N/A (spatial analysis did not complete)"
}
if(exists("hotspot_tracts") && is.data.frame(hotspot_tracts) && nrow(hotspot_tracts) > 0) {
n_hotspots <- nrow(hotspot_tracts)
} else {
n_hotspots <- "N/A"
}
# Get disparity info
max_disparity_group <- equity_summary$majority_type[which.max(equity_summary$`Mean Eviction Rate`)]
max_disparity_ratio <- round(max(equity_summary$`Disparity Ratio`, na.rm = TRUE), 2)
load("D:/pen/MUSA5080PublicPolicyAnalytics/portfolio-setup-Mayaano/.RData")
